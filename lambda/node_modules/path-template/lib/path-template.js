var PathTemplate = exports;

var SLASH = ["string", "/"];
var DOT = ["string", "."];

var tokenize = function (string) {
	return string.split(/([\/:*.)(])/).filter(function (x) {
		return x;
	});
};

var lex = function (tokens) {
	var parts = [],
		i,
		token,
		optionalPartsConsumed,
		optionalParts;
	for (i = 0; i < tokens.length; i += 1) {
		token = tokens[i];
		switch (token) {
		case ":":
			parts.push(["variable", tokens[i += 1]]);
			break;
		case "*":
			token = tokens[i += 1];
			if (token === "/" || token === ".") {
				i -= 1;
				token = null;
			}
			parts.push(["splat", token]);
			break;
		case "(":
			optionalPartsConsumed = lex(tokens.slice(i + 1));
			optionalParts = optionalPartsConsumed[0];
			parts.push(["option", optionalParts.length]);
			parts = parts.concat(optionalParts);
			i += optionalPartsConsumed[1] + 1;
			break;
		case ")":
			return [parts, i];
		default:
			parts.push(["string", token]);
		}
	}
	return [parts, i];
};

/**
 * Returns a compiled path template, generated from the given string.
 * 
 * @example
 * var template = PathTemplate.parse("/users/:userID");
 * 
 * @param {string} string A URL path template
 * @returns {PathTemplate} A compiled path template
 */
PathTemplate.parse = function (string) {
	var partsConsumed = lex(tokenize(string));
	return partsConsumed[0];
};

/**
 * Returns the string representation of a compiled path template.
 * 
 * @example
 * console.log(PathTemplate.inspect(template));
 * 
 * @param {PathTemplate} template A compiled path template
 * @returns {string} the string representation of template
 */
PathTemplate.inspect = function (template) {
	var closeOptionIn = -1,
		results = template.map(function (part) {
			var out;
			switch (part[0]) {
			case "variable":
				out = ":" + part[1];
				break;
			case "splat":
				out = part[1] ? "*" + part[1] : "*";
				break;
			case "option":
				out = "(";
				closeOptionIn = part[1];
				break;
			default:
				out = part[1];
			}
			if (closeOptionIn === 0) {
				out += ")";
			}
			closeOptionIn -= 1;
			return out;
		});
	return results.join("");
};

/**
 * Returns the variable names (including splats/globs) used in a path template.
 * 
 * @example
 * var keys = PathTemplate.variables(template);
 * 
 * @param {PathTemplate} template A compiled path template
 * @returns {Array} the variable names used in template
 */
PathTemplate.variables = function (template) {
	return template.reduce(function (acc, part) {
		var type = part[0],
			val = part[1];
		if ((type === "variable" || type === "splat") && val) {
			acc.push(val);
		}
		return acc;
	}, []);
};

var formatParts = function (template, obj) {
	var result = [],
		i,
		part,
		value;
	for (i = 0; i < template.length; i += 1) {
		part = template[i];
		switch (part[0]) {
		case "string":
			value = part[1];
			if (!(value === "/" && result[result.length - 1] === "/")) {
				result.push(value);
			}
			break;
		case "variable":
			value = obj[part[1]];
			if (!(typeof value === "undefined")) {
				result.push(value);
			}
			break;
		case "splat":
			value = obj[part[1]];
			if (Array.isArray(value)) {
				result.push(value.join("/"));
			} else if (!(typeof value === "undefined")) {
				result.push(value);
			}
			break;
		case "option":
			value = formatParts(template.slice(i + 1, i + part[1] + 1), obj);
			if (value.length >= part[1]) {
				result = result.concat(value);
				i += value.length;
			} else {
				i += part[1];
			}
			break;
		}
	}
	return result;
};

/**
 * Returns a URL path generated by substituting the variables in template with
 * the values of the correspondingly named properties in an object.
 * 
 * @example
 * var url = PathTemplate.format(template, {userID: 1});
 * 
 * @param {PathTemplate} template A compiled path template
 * @param {Object} obj An object with properties corresponding with the
 *                     variables in template
 * @returns {string} the URL path generated from combining template and obj.
 */
PathTemplate.format = function (template, obj) {
	return formatParts(template, obj).join("");
};

var matcherFinished = function(matcher) {
	var i = matcher.index,
		max = matcher.template.length,
		current = matcher.template[i];
	return i === max || (i + 1 === max && current[0] === "splat") ||
		(current[0] === "option" && i + 1 + current[1] === max);
};

var copyCaptures = function(captures, prototype) {
	var copy = Object.create(prototype || {}),
		prop;
	for (prop in captures) {
		if (captures.hasOwnProperty(prop)) {
			copy[prop] = captures[prop];
		}
	}
	return copy;
};

var matcherAdvancers = {
	string: function (matcher, string, value) {
		if (string === value) {
			return [{template: matcher.template, index: matcher.index + 1,
				captures: matcher.captures}];
		}
	},
	
	variable: function (matcher, string, value) {
		var captures = copyCaptures(matcher.captures);
		captures[value] = string;
		return [{template: matcher.template, index: matcher.index + 1,
			captures: captures}];
	},
	
	splat: function (matcher, string, value) {
		var captures = copyCaptures(matcher.captures),
			matchNext,
			newMatcher;
			
		if (value && !captures[value]) {
			captures[value] = [];
		}
		
		// try the next part of the template to see if the splat has ended
		matchNext = advanceMatcher({template: matcher.template,
			index: matcher.index + 1, captures: captures}, string);
		
		// if the next didn't match and it's a slash, try skipping it
		// this is meant for zero width splats, e.g. /foo/*/bar match /foo/bar
		if (!matchNext && arrayEql(matcher.template[matcher.index + 1], SLASH)){
			matchNext = advanceMatcher({template: matcher.template,
				index: matcher.index + 2, captures: captures}, string);
		}
		
		if (matchNext) {
			captures = copyCaptures(captures);
		}
		
		if (string !== "/" && value) {
			captures[value] = captures[value].concat(string);
		}
		
		newMatcher = {template: matcher.template, index: matcher.index,
			captures: captures};
		if (matchNext) {
			return matchNext.concat(newMatcher);
		} else {
			return [newMatcher];
		}
	},
	
	option: function (matcher, string, value) {
		var captures = copyCaptures(matcher.captures),
			matchers = [],
			matchNext,
			matchAhead;
		
		matchNext = advanceMatcher({template: matcher.template,
			index: matcher.index + 1, captures: captures}, string);
		
		if (matchNext) {
			captures = copyCaptures(captures);
			matchers = matchers.concat(matchNext);
		}
		
		matchAhead = advanceMatcher({template: matcher.template,
			index: matcher.index + 1 + value, captures: captures}, string);
		
		if (matchAhead) {
			matchers = matchers.concat(matchAhead);
		}
		
		return matchers;
	}
};

var advanceMatcher = function(matcher, string) {
	var part = matcher.template[matcher.index];
	if (part && part[0]) {
		return matcherAdvancers[part[0]](matcher, string, part[1]);
	}
};

var flattenCompact = function (array) {
	return array.reduce(function (acc, ary) {
		if (ary) {
			acc = acc.concat(ary);
		}
		return acc;
	}, []);
};

var outputCaptures = function (captures, template) {
	var last = template.slice(-1)[0],
		val = last[1];
	captures = copyCaptures(captures, {template: template});
	if (last[0] === "splat" && typeof captures[val] === "undefined") {
		captures[val] = [];
	}
	return captures;
};

/**
 * If string is a path matching the format of template, returns a match object
 * containing the parameters found in the path, otherwise returns undefined.
 * 
 * An array of templates can be given as the first argument, in which case a
 * match object will be returned if any of the templates match. The match object
 * will have a "template" property referencing the template with which the path
 * matched.
 * 
 * @example
 * var match = PathTemplate.match(templates, url.pathname);
 * 
 * @param {Array|PathTemplate} templates An array of, or single, compiled path
 *                                       templates
 * @param {string} template A URL path to match against
 * @returns {Object|undefined} the values of the variables used in the matched
 *                             template, or undefined if none match
 */
PathTemplate.match = function (templates, string) {
	if (typeof templates[0][0] === "string") {
		templates = [templates];
	}
	var matchers = templates.map(function (template) {
			return {template: template, index: 0, captures: {}};
		}),
		parts = tokenize(string),
		part,
		matcher,
		advancer = function (m) {
			return advanceMatcher(m, part);
		};
	
	for (i = 0; i < parts.length; i += 1) {
		part = parts[i];
		matchers = flattenCompact(matchers.map(advancer));
		if (matchers.length === 0) {
			return;
		}
	}
	for (i = 0; i < matchers.length; i += 1) {
		matcher = matchers[i];
		if (matcherFinished(matcher)) {
			return outputCaptures(matcher.captures, matcher.template);
		}
	}
};

var arrayEql = function (a, b) {
	return a && b && !(a < b || a > b);
};

var addTemplate = function (template, other) {
	if (other.length === 0) {
		return template.slice();
	}
	var tLast = template[template.length - 1],
		oFirst = other[0];
	if (arrayEql(tLast, oFirst) && arrayEql(tLast, SLASH)) {
		other = other.slice(1);
	} else if (!(arrayEql(tLast, SLASH) || arrayEql(oFirst, SLASH) ||
		arrayEql(tLast, DOT) || arrayEql(oFirst, DOT))) {
		other = [SLASH].concat(other);
	}
	return template.concat(other);
};

/**
 * Returns a new path template by appending the path described by string.
 * 
 * @example
 * var photoTemplate = PathTemplate.add(template, "/photos/:photoID");
 * 
 * @param {PathTemplate} template A compiled path template
 * @param {string} string A URL path template
 * @returns {PathTemplate} A compiled path template
 */
PathTemplate.add = function (template, string) {
	return addTemplate(template, PathTemplate.parse(string));
};

var range = function (start, end, exclusive) {
	var acc = [],
		i;
	for (i = start; exclusive ? i < end : i <= end; i += 1) {
		acc.push(i);
	}
	return acc;
};

var zip = function (array, other) {
	var acc = [],
		i;
	for (i = 0; i < array.length; i += 1) {
		acc.push([array[i], other[i]]);
	}
	return acc;
};

var subsectionIndexOf = function (array, other) {
	var aLength = array.length,
		oLength = other.length,
		diffrence = aLength - oLength,
		sections = zip(range(0, diffrence), range(oLength - 1, aLength, true)),
		i,
		start,
		end;
	for (i = 0; i < sections.length; i += 1) {
		start = sections[i][0];
		end = sections[i][1];
		if (arrayEql(array.slice(start, end + 1), other)) {
			return sections[i];
		}
	}
};

var withoutTemplate = function (template, other) {
	var toRemove = subsectionIndexOf(template, other),
		start,
		end,
		result = template;
	if (toRemove) {
		start = template.slice(0, toRemove[0]);
		end = template.slice(toRemove[1] + 1);
		result = addTemplate(start, end);
	}
	return result;
};

/**
 * Returns a new path without the path segments described by string.
 * 
 * @example
 * var photosTemplate = PathTemplate.without(photoTemplate, "/:photoID");
 * 
 * @param {PathTemplate} template A compiled path template
 * @param {string} string A URL path template
 * @returns {PathTemplate} A compiled path template
 */
PathTemplate.without = function (template, string) {
	return withoutTemplate(template, PathTemplate.parse(string));
};
